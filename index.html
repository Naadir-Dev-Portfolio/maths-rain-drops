<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arithmetic Rain Game</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(to bottom, #1e3c72, #2a5298);
      font-family: sans-serif;
    }
    #hud {
      position: absolute;
      top: 2vh;
      left: 2vw;
      color: #fff;
      font-size: 4vw;
      min-font-size: 16px;
      z-index: 10;
    }
    /* Instructions box */
    #instructions {
      position: absolute;
      top: 12vh;
      left: 2vw;
      background: rgba(255, 255, 255, 0.2);
      color: #FFF;
      border: 1px solid rgba(255, 255, 255, 0.5);
      border-radius: 8px;
      padding: 0.75em 1em;
      max-width: 220px;
      font-size: 1rem;
      line-height: 1.3;
      backdrop-filter: blur(4px);
      z-index: 10;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 10vw;
      text-align: center;
      z-index: 20;
      display: none;
    }
    #message {
      position: absolute;
      top: 40%;
      width: 100%;
      text-align: center;
      font-size: 8vw;
      color: #fff;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 20;
    }
    #answers {
      position: absolute;
      bottom: 2vh;
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      padding: 0 2vw;
      z-index: 10;
    }
    #answers button {
      flex: 1 1 25%;
      max-width: 160px;
      margin: 0.5vh 0.5vw;
      padding: 1em 1.5em;
      font-size: 1.4rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background-color: #f0ad4e;
      color: #fff;
      transition: background-color 0.3s, transform 0.15s;
    }
    #answers button:hover {
      background-color: #ec971f;
      transform: scale(1.05);
    }
    #gameContainer canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="hud">
    Score: <span id="score">0</span> | Lives: <span id="lives">3</span>
  </div>
  <div id="instructions">
    <strong>How to Play:</strong><br>
    Click the correct answer button to "catch" each falling problem.<br>
    Solve before it reaches the bottom.<br>
    You have 3 lives; wrong answers or timeouts cost a life.<br>
    Difficulty increases every 5 points.<br>
    Good luck!
  </div>
  <div id="gameOver">Game Over</div>
  <div id="message"></div>
  <div id="answers"></div>
  <div id="gameContainer"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const DROP_SIZE = 120;
    let scene, camera, renderer;
    let activeProblems = [];
    let score = 0;
    let lives = 3;
    const maxProblems = 3;
    const clock = new THREE.Clock();
    let gameWidth = window.innerWidth;
    let gameHeight = window.innerHeight;

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(
        -gameWidth/2, gameWidth/2,
        gameHeight/2, -gameHeight/2,
        1, 1000
      );
      camera.position.z = 10;
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(gameWidth, gameHeight);
      document.getElementById('gameContainer').appendChild(renderer.domElement);

      for (let i = 0; i < maxProblems; i++) addNewProblem();
      updateAnswerButtons();
      animate();
    }

    function showMessage(text, color) {
      const msg = document.getElementById('message');
      msg.textContent = text;
      msg.style.color = color;
      msg.style.opacity = 1;
      setTimeout(() => msg.style.opacity = 0, 500);
    }

    function createDropSprite(problem) {
      const size = DROP_SIZE;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const context = canvas.getContext('2d');
      problem.canvas = canvas;
      problem.context = context;
      problem.texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: problem.texture, transparent: true });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(size, size, 1);
      return sprite;
    }

    function updateDropSprite(problem) {
      const ctx = problem.context;
      const size = DROP_SIZE;
      ctx.clearRect(0, 0, size, size);
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/2 - 5, 0, Math.PI*2);
      ctx.fillStyle = '#80dfff';
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#fff';
      ctx.stroke();
      ctx.fillStyle = '#000';
      ctx.font = `${Math.floor(size/4)}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(problem.text, size/2, size/2);
      const progress = Math.max(0, problem.timeLeft) / problem.totalTime;
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/2 - 3, -Math.PI/2, -Math.PI/2 + progress*2*Math.PI);
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#ff0000';
      ctx.stroke();
      problem.texture.needsUpdate = true;
    }

    function createArithmeticProblem() {
      const problem = {};
      const difficulty = Math.floor(score / 5);
      let a, b, op, result;
      const operators = ['+', '-'];
      if (difficulty > 2) operators.push('*');
      if (difficulty > 4) operators.push('/');
      op = operators[Math.floor(Math.random() * operators.length)];
      if (op === '*' || op === '/') {
        const level = Math.max(0, difficulty - 2);
        const maxFactor = Math.min(12, 2 + level*2);
        if (op === '/') {
          result = Math.floor(Math.random() * (maxFactor - 1)) + 2;
          b = Math.floor(Math.random() * (maxFactor - 1)) + 2;
          a = result * b;
        } else {
          a = Math.floor(Math.random() * (maxFactor - 1)) + 2;
          b = Math.floor(Math.random() * (maxFactor - 1)) + 2;
          result = a * b;
        }
      } else {
        const maxNum = 10 + difficulty*5;
        a = Math.floor(Math.random() * maxNum) + 1;
        b = Math.floor(Math.random() * maxNum) + 1;
        result = op === '+' ? a + b : a - b;
      }
      problem.text = `${a} ${op} ${b}`;
      problem.answer = Math.round(result * 100) / 100;
      problem.x = Math.random() * (gameWidth - DROP_SIZE) - (gameWidth/2 - DROP_SIZE/2);
      problem.y = gameHeight/2 - DROP_SIZE/2;
      problem.speed = 20 + difficulty*5;
      problem.totalTime = (problem.y - (-gameHeight/2)) / problem.speed;
      problem.timeLeft = problem.totalTime;
      problem.sprite = createDropSprite(problem);
      problem.sprite.position.set(problem.x, problem.y, 0);
      scene.add(problem.sprite);
      return problem;
    }

    function addNewProblem() {
      activeProblems.push(createArithmeticProblem());
      updateAnswerButtons();
    }

    function updateAnswerButtons() {
      const div = document.getElementById('answers');
      div.innerHTML = '';
      const corrects = activeProblems.map(p => p.answer);
      const opts = corrects.slice();
      while (opts.length < 6) {
        const rnd = Math.floor(Math.random() * (20 + Math.floor(score/5)*10)) + 1;
        if (!opts.includes(rnd)) opts.push(rnd);
      }
      opts.sort(() => Math.random() - 0.5);
      opts.forEach(val => {
        const btn = document.createElement('button');
        btn.textContent = val;
        btn.onclick = () => checkAnswer(val);
        div.appendChild(btn);
      });
    }

    function checkAnswer(selected) {
      let found = false;
      for (let i = activeProblems.length - 1; i >= 0; i--) {
        if (activeProblems[i].answer === selected) {
          scene.remove(activeProblems[i].sprite);
          showMessage('Correct!', '#00ff00');
          activeProblems.splice(i, 1);
          score++;
          document.getElementById('score').textContent = score;
          addNewProblem();
          found = true;
          break;
        }
      }
      if (!found) {
        showMessage('Wrong!', '#ff0000');
        loseLife();
      }
      updateAnswerButtons();
    }

    function loseLife() {
      lives--;
      document.getElementById('lives').textContent = lives;
      if (lives <= 0) gameOver();
    }

    function gameOver() {
      document.getElementById('gameOver').style.display = 'block';
    }

    function animate() {
      const delta = clock.getDelta();
      activeProblems.forEach((p, i) => {
        p.timeLeft -= delta;
        p.sprite.position.y -= p.speed * delta;
        updateDropSprite(p);
        if (p.timeLeft <= 0 || p.sprite.position.y < -gameHeight/2) {
          scene.remove(p.sprite);
          showMessage("Time's Up!", '#ff0000');
          activeProblems.splice(i, 1);
          loseLife();
          addNewProblem();
        }
      });
      renderer.render(scene, camera);
      if (lives > 0) requestAnimationFrame(animate);
    }

    window.addEventListener('resize', () => {
      const oldW = gameWidth;
      const oldH = gameHeight;
      gameWidth = window.innerWidth;
      gameHeight = window.innerHeight;
      activeProblems.forEach(p => {
        p.x = Math.random() * (gameWidth - DROP_SIZE) - (gameWidth/2 - DROP_SIZE/2);
        p.y *= gameHeight / oldH;
        p.sprite.position.set(p.x, p.y, 0);
        p.totalTime = (p.y - (-gameHeight/2)) / p.speed;
        p.timeLeft = Math.min(p.timeLeft * (gameHeight/oldH), p.totalTime);
      });
      camera.left = -gameWidth/2;
      camera.right = gameWidth/2;
      camera.top = gameHeight/2;
      camera.bottom = -gameHeight/2;
      camera.updateProjectionMatrix();
      renderer.setSize(gameWidth, gameHeight);
    });

    init();
  </script>
</body>
</html>

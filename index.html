<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arithmetic Rain Game</title>
  <style>
    /*---------------------- Reset & Base ----------------------*/
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: linear-gradient(to bottom, #1e3c72, #2a5298);
      font-family: sans-serif;
    }

    /*---------------------- HUD ----------------------*/
    #hud {
      position: absolute;
      top: 10px; left: 10px;
      color: #fff;
      font-size: 1.2rem;
      z-index: 10;
    }

    /*---------------------- Instructions Toggle ----------------------*/
    #toggleInstructions {
      position: absolute;
      top: 50px; left: 10px;
      background: rgba(255,255,255,0.3);
      border: none;
      padding: 8px 12px;
      cursor: pointer;
      color: #fff;
      font-size: 1rem;
      border-radius: 4px;
      z-index: 10;
    }

    /*---------------------- Instructions Panel ----------------------*/
    #instructions {
      position: absolute;
      top: 90px; left: 10px;
      width: 220px;
      max-height: 0;
      overflow: hidden;
      background: rgba(255,255,255,0.2);
      backdrop-filter: blur(5px);
      border-radius: 8px;
      transition: max-height 0.3s ease;
      color: #fff;
      padding: 0 12px;
      z-index: 10;
    }
    #instructions.expanded {
      max-height: 300px;
      padding: 12px;
    }

    /*---------------------- Game Over & Message ----------------------*/
    #gameOver {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 4rem;
      z-index: 20;
      display: none;
    }
    #message {
      position: absolute;
      top: 40%;
      width: 100%;
      text-align: center;
      font-size: 2.5rem;
      color: #fff;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 20;
    }

    /*---------------------- Answer Buttons ----------------------*/
    #answers {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      z-index: 10;
    }
    #answers button {
      width: 25%;
      max-width: 150px;
      margin: 5px;
      padding: 0.8em 1.2em;
      font-size: 1.4rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background-color: #f0ad4e;
      color: #fff;
      transition: background-color 0.3s, transform 0.15s;
    }
    #answers button:hover {
      background-color: #ec971f;
      transform: scale(1.05);
    }

    /*---------------------- Game Container ----------------------*/
    #gameContainer {
      width: 100%;
      height: 100%;
      overflow: visible;
    }
  </style>
</head>
<body>
  <div id="hud">
    Score: <span id="score">0</span> |
    Lives: <span id="lives">3</span>
  </div>

  <button id="toggleInstructions">▶ Instructions</button>
  <div id="instructions">
    <p>Catch the drops by clicking the correct answer!</p>
    <ul>
	  <br>
      Solve the arithmetic before the drop hits the bottom.
	  </br>
	  <br>
      Correct → +1 score; Wrong or timeout → −1 life.
	  </br>
	  <br>
      Game ends at 0 lives.
	<br>
	</br>
    </ul>
  </div>

  <div id="gameOver">Game Over</div>
  <div id="message"></div>
  <div id="answers"></div>
  <div id="gameContainer"></div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ---- Globals ----
    let scene, camera, renderer;
    let activeProblems = [];
    let score = 0, lives = 3;
    const DROP_SIZE = 120;           // fixed size for drops
    const baseDrops = 3;             // starting number of drops
    const clock = new THREE.Clock(); // for timing

    // viewport dimensions
    let gameWidth = window.innerWidth;
    let gameHeight = window.innerHeight;

    // compute how many drops based on score
    function getMaxDrops(currentScore) {
      return baseDrops + Math.floor(currentScore / 5);
    }

    // ---- Initialization ----
    function init() {
      // scene + ortho camera
      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(
        gameWidth / -2, gameWidth / 2,
        gameHeight / 2, gameHeight / -2,
        1, 1000
      );
      camera.position.z = 10;
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(gameWidth, gameHeight);
      document.getElementById("gameContainer").appendChild(renderer.domElement);

      // create initial drops
      for (let i = 0; i < getMaxDrops(score); i++) {
        addNewProblem();
      }
      updateAnswerButtons();
      animate();

      // instructions toggle
      const toggleBtn = document.getElementById("toggleInstructions");
      const instr    = document.getElementById("instructions");
      toggleBtn.addEventListener("click", () => {
        const open = instr.classList.toggle("expanded");
        toggleBtn.textContent = (open ? "▼ " : "▶ ") + "Instructions";
      });
    }

    // ---- UI Helpers ----
    function showMessage(text, color) {
      const msg = document.getElementById("message");
      msg.textContent = text;
      msg.style.color   = color;
      msg.style.opacity = 1;
      setTimeout(() => msg.style.opacity = 0, 500);
    }

    // ---- Sprite Creation & Updating ----
    function createDropSprite(problem) {
      const size = DROP_SIZE;
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      problem.canvas  = canvas;
      problem.context = ctx;
      problem.texture = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({ map: problem.texture, transparent: true });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(size, size, 1);
      return spr;
    }

    function updateDropSprite(problem) {
      const ctx = problem.context;
      const size = problem.canvas.width;
      ctx.clearRect(0, 0, size, size);

      // circle body
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/2 - 5, 0, Math.PI * 2);
      ctx.fillStyle = "#80dfff";
      ctx.fill();
      ctx.lineWidth   = 3;
      ctx.strokeStyle = "#fff";
      ctx.stroke();

      // arithmetic text
      ctx.fillStyle    = "#000";
      ctx.font         = "28px Arial";
      ctx.textAlign    = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(problem.text, size/2, size/2);

      // timer arc
      const progress = Math.max(0, problem.timeLeft) / problem.totalTime;
      ctx.beginPath();
      ctx.arc(
        size/2, size/2,
        size/2 - 3,
        -Math.PI/2,
        -Math.PI/2 + progress * 2 * Math.PI,
        false
      );
      ctx.lineWidth   = 4;
      ctx.strokeStyle = "#ff0000";
      ctx.stroke();

      problem.texture.needsUpdate = true;
    }

    // ---- Problem Generation ----
    function createArithmeticProblem() {
      const problem    = {};
      const difficulty = Math.floor(score / 5);
      let a, b, op, answer;

      // pick operator set
      const operators = ["+", "-"];
      if (difficulty >= 3) {
        operators.push("*", "/");
      }
      op = operators[Math.floor(Math.random() * operators.length)];

      if (op === "*" || op === "/") {
        // ramping factor limit from 2+difficulty up to 12
        const maxFactor = Math.min(12, 2 + difficulty);
        if (op === "*") {
          a = Math.ceil(Math.random() * maxFactor);
          b = Math.ceil(Math.random() * maxFactor);
          answer = a * b;
        } else {
          // division: ensure no remainder
          answer = Math.ceil(Math.random() * maxFactor);
          b      = Math.ceil(Math.random() * maxFactor);
          a      = answer * b;
        }
      } else {
        // addition / subtraction
        const maxNum = 10 + difficulty * 5;
        a = Math.ceil(Math.random() * maxNum);
        b = Math.ceil(Math.random() * maxNum);
        if (op === "-" && a < b) [a, b] = [b, a];
        answer = (op === "+") ? a + b : a - b;
      }

      problem.text   = `${a} ${op} ${b}`;
      problem.answer = answer;

      // starting pos and timing
      problem.x = Math.random() * (gameWidth - DROP_SIZE) - gameWidth/2 + DROP_SIZE/2;
      problem.y = gameHeight/2 - DROP_SIZE/2;
      problem.speed     = 20 + difficulty * 5;
      problem.totalTime = (problem.y - (-gameHeight/2)) / problem.speed;
      problem.timeLeft  = problem.totalTime;

      // sprite
      problem.sprite = createDropSprite(problem);
      problem.sprite.position.set(problem.x, problem.y, 0);
      scene.add(problem.sprite);

      return problem;
    }

    function addNewProblem() {
      activeProblems.push(createArithmeticProblem());
      updateAnswerButtons();
    }

    // ---- Answer Buttons ----
    function updateAnswerButtons() {
      const div = document.getElementById("answers");
      div.innerHTML = "";
      const corrects = activeProblems.map(p => p.answer);
      const opts     = [...corrects];
      while (opts.length < 6) {
        const rnd = Math.ceil(Math.random() * (20 + Math.floor(score/5)*10));
        if (!opts.includes(rnd)) opts.push(rnd);
      }
      opts.sort(() => Math.random() - 0.5)
          .forEach(opt => {
            const btn = document.createElement("button");
            btn.textContent = opt;
            btn.onclick     = () => checkAnswer(opt);
            div.appendChild(btn);
          });
    }

    function checkAnswer(selected) {
      let found = false;
      for (let i = activeProblems.length - 1; i >= 0; i--) {
        if (activeProblems[i].answer === selected) {
          // pop effect
          activeProblems[i].sprite.scale.set(DROP_SIZE * 1.5, DROP_SIZE * 1.5, 1);
          showMessage("Correct!", "#00ff00");
          scene.remove(activeProblems[i].sprite);
          activeProblems.splice(i, 1);
          score++;
          document.getElementById("score").textContent = score;
          found = true;
          break;
        }
      }
      if (!found) {
        showMessage("Wrong!", "#ff0000");
        loseLife();
      }
      // refill to desired count
      while (activeProblems.length < getMaxDrops(score)) {
        addNewProblem();
      }
      updateAnswerButtons();
    }

    // ---- Lives & Game Over ----
    function loseLife() {
      lives--;
      document.getElementById("lives").textContent = lives;
      if (lives <= 0) gameOver();
    }
    function gameOver() {
      document.getElementById("gameOver").style.display = "block";
    }

    // ---- Main Loop ----
    function animate() {
      const delta = clock.getDelta();
      for (let i = activeProblems.length - 1; i >= 0; i--) {
        const p = activeProblems[i];
        p.timeLeft -= delta;
        p.sprite.position.y -= p.speed * delta;
        updateDropSprite(p);

        if (p.timeLeft <= 0 || p.sprite.position.y < -gameHeight/2) {
          showMessage("Time's Up!", "#ff0000");
          scene.remove(p.sprite);
          activeProblems.splice(i, 1);
          loseLife();
        }
      }
      while (activeProblems.length < getMaxDrops(score)) {
        addNewProblem();
      }
      renderer.render(scene, camera);
      if (lives > 0) requestAnimationFrame(animate);
    }

    // ---- Handle Resize ----
    window.addEventListener("resize", () => {
      gameWidth  = window.innerWidth;
      gameHeight = window.innerHeight;
      camera.left   = -gameWidth/2;
      camera.right  =  gameWidth/2;
      camera.top    =  gameHeight/2;
      camera.bottom = -gameHeight/2;
      camera.updateProjectionMatrix();
      renderer.setSize(gameWidth, gameHeight);

      // reposition all drops within new bounds
      activeProblems.forEach(p => {
        p.x = Math.random() * (gameWidth - DROP_SIZE) - gameWidth/2 + DROP_SIZE/2;
        p.y = gameHeight/2 - DROP_SIZE/2;
        p.sprite.position.set(p.x, p.y, 0);
        p.totalTime = (p.y - (-gameHeight/2)) / p.speed;
        p.timeLeft  = Math.min(p.timeLeft, p.totalTime);
      });
    });

    // start
    init();
  </script>
</body>
</html>
